### 先从进程和线程说起

1. 进程：通常一个 App 应用程序被分配一个固定的内存空间，执行一个主进程
2. 线程：一个进程内可以分配多个线程，去执行具体的任务，如交互、网络通信等

### 浏览器内的进程和线程

现代浏览器的设计非常复杂，以 chrome 浏览器举例，启动后会开启**浏览器进程**这个主进程，然后这个进程再去开启其他的进程比如：**网络进程**、**渲染进程**等：

1. 浏览器进程：主要负责 界面展示、用户交互、子进程管理等
2. 网络进程：网络通信、加载资源等
3. 渲染进程：会有一个渲染的主线程，负责执行 HTML、CSS、JS 代码。默认情况下，浏览器会为**每一个**标签页开启一个渲染进程，保证标签页之间互不影响。

> - 未来可能会有所改变，因为内存占用空间太多
> - 可能会针对不同操作系统、不同平台使用不同的模式

### 事件循环发生的地方，渲染主线程

渲染主线程是最烦忙的线程，处理的任务包括但不限于：

- 解析 HTML、CSS
- 计算样式、布局
- 处理图层
- 渲染画面
- 执行 js 代码
- 处理事件
- 处理计时器

那么，渲染主线程如何调度任务？
比如：

- 正在执行某个 JS 代码，用户发生了点击的交互事件，如何处理？
- 用户交互事件和定时器处理事件同时触发，如何处理？

#### 消息队列

message queue，有些翻译也叫**事件队列**。（w3c 标准是 event loop，chrome 实现叫做 message loop）

1. 渲染主线程最开始就直接开启一个**无限循环的 for 循环**
2. 每一次循环都会检查队列中是否还有任务存在。有，就取出执行，任务执行完之后继续循环检查有没有任务；没有，主线程就进入休眠；
3. 所有线程（包括其他进程的线程）可以随时向队列里添加任务。先进先出，新任务会加在队列末尾。如果加新任务的时候主线程是休眠状态，主线程就会被唤醒，继续无限循环。

这个循环的过程就叫**事件循环**

### 异步

JS 是一门单线程的语言，因为它运行在浏览器的渲染主线程中。主线程只有一个，但承担的任务很多。
代码执行过程中，会产生一些无法立即处理的任务，比如：

- 计时任务，如 `setTimeout`、`setInterval`等；
- 网络通信任务，如 `XHR` 等；
- 用户交互事件的监听处理任务，如`addEventListener`等。

如果主线程不对这些任务特殊处理，一直等到可以处理的时机再去执行，会造成主线程**阻塞**，导致浏览器「卡死」。
因此主线程需要采用**异步**的方式，保证主线程**永不阻塞**。

比如对于计时任务：

1. 执行到对应代码时，通知计时线程开启计时；
2. 主线程继续检查消息队列，执行下一个任务；
3. 计时线程内对应的计时结束时，将回调函数包装成任务放入此时的消息队列末尾；
4. 等到主线程检查消息队列检查该计时任务的回调函数任务时，执行任务。

这样子就最大程度的保证了浏览器永不阻塞。

#### JS 为何会阻塞渲染

因为 JS 执行 和 绘制 都由渲染主线程调度，主线程在执行一段较长耗时的 JS 代码时，就会阻塞绘制

**单线程是异步产生的原因**
**事件循环是异步的实现方式**

### 任务优先级

实际上任务本身没有优先级，在队列中始终 **FIFO** （先进先出）。
**但队列是有优先级的。**

（之前是有两个队列，MacroTask 宏任务队列 和 MicroTask 微任务队列，但是随着浏览器复杂度急剧提升，标准已经更改，不再使用宏队列的说法）
W3C 最新解释：

- 每个任务都有一个类型，同一个类型的任务必须在一个队列，不同类型可以分属于不同的消息队列（也即不同类型的任务可以放在一个队列）。在某次事件循环中，浏览器根据实际情况自行选择从某个队列中取出任务执行。
- 必须有一个微队列（microtask queue），微队列中的任务优先级**最高**

在目前的 chrome 的实现中，至少有以下队列：

- 延时队列：计时器到达后的回调任务，优先级「中」；
- 交互队列：用户交互事件后的回调任务，优先级「高」；
- 微队列：需要最快执行的任务（主要方式有 Promise、MutationObserver），优先级「最高」。

其他队列跟开发关系较小可忽略

> 怎么把一个函数立即添加到微队列中：
> `Promise.resolve().then(函数)`

> JS 中的计时器能做到精准计时吗？为什么？
> 不行，因为：
>
> 1. 硬件层面本身就不精确，计算机内部没有原子钟
> 2. 操作系统本身的计时函数就有微量偏差，JS 调用的还是操作系统本身的计时函数
> 3. 按照 W3C 的标准，浏览器的 C++ 源码实现计时器时，如果**嵌套层级超过 5 层**，则会带有 4 毫秒的最少时间
> 4. 受事件循环的影响，计时器的回调函数的任务只能在主线程空闲时被调度执行，所以有偏差
